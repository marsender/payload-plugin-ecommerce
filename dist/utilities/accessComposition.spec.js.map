{"version":3,"sources":["../../src/utilities/accessComposition.spec.ts"],"sourcesContent":["import type { Access, AccessArgs, Where } from 'payload'\n\nimport { accessAND, conditional, accessOR } from './accessComposition'\n\n// Mock access args for testing\nconst mockArgs: AccessArgs = {\n  req: {\n    user: null,\n    headers: new Headers(),\n    payload: {} as any,\n    context: {},\n  } as any,\n}\n\nconst mockArgsWithUser: AccessArgs = {\n  req: {\n    user: { id: '123', email: 'test@example.com' },\n    headers: new Headers(),\n    payload: {} as any,\n    context: {},\n  } as any,\n}\n\ndescribe('Access Composition Utilities', () => {\n  describe('or', () => {\n    it('should return true when first checker returns true', async () => {\n      const checker1: Access = async () => true\n      const checker2: Access = async () => false\n\n      const result = await accessOR(checker1, checker2)(mockArgs)\n\n      expect(result).toBe(true)\n    })\n\n    it('should return true when any checker returns true', async () => {\n      const checker1: Access = async () => false\n      const checker2: Access = async () => true\n      const checker3: Access = async () => false\n\n      const result = await accessOR(checker1, checker2, checker3)(mockArgs)\n\n      expect(result).toBe(true)\n    })\n\n    it('should return false when all checkers return false', async () => {\n      const checker1: Access = async () => false\n      const checker2: Access = async () => false\n      const checker3: Access = async () => false\n\n      const result = await accessOR(checker1, checker2, checker3)(mockArgs)\n\n      expect(result).toBe(false)\n    })\n\n    it('should combine Where queries with OR logic', async () => {\n      const checker1: Access = async () => ({\n        customer: { equals: '123' },\n      })\n      const checker2: Access = async () => ({\n        status: { equals: 'published' },\n      })\n\n      const result = await accessOR(checker1, checker2)(mockArgs)\n\n      expect(result).toEqual({\n        or: [{ customer: { equals: '123' } }, { status: { equals: 'published' } }],\n      })\n    })\n\n    it('should return true when one checker returns true and others return Where queries', async () => {\n      const checker1: Access = async () => ({\n        customer: { equals: '123' },\n      })\n      const checker2: Access = async () => true\n\n      const result = await accessOR(checker1, checker2)(mockArgs)\n\n      expect(result).toBe(true)\n    })\n\n    it('should ignore false values when combining Where queries', async () => {\n      const checker1: Access = async () => false\n      const checker2: Access = async () => ({\n        customer: { equals: '123' },\n      })\n      const checker3: Access = async () => false\n      const checker4: Access = async () => ({\n        status: { equals: 'published' },\n      })\n\n      const result = await accessOR(checker1, checker2, checker3, checker4)(mockArgs)\n\n      expect(result).toEqual({\n        or: [{ customer: { equals: '123' } }, { status: { equals: 'published' } }],\n      })\n    })\n\n    it('should return a single Where query when only one checker returns a Where query', async () => {\n      const checker1: Access = async () => false\n      const checker2: Access = async () => ({\n        customer: { equals: '123' },\n      })\n      const checker3: Access = async () => false\n\n      const result = await accessOR(checker1, checker2, checker3)(mockArgs)\n\n      expect(result).toEqual({\n        or: [{ customer: { equals: '123' } }],\n      })\n    })\n\n    it('should short-circuit on first true result for performance', async () => {\n      let secondCheckerCalled = false\n\n      const checker1: Access = async () => true\n      const checker2: Access = async () => {\n        secondCheckerCalled = true\n        return false\n      }\n\n      await accessOR(checker1, checker2)(mockArgs)\n\n      expect(secondCheckerCalled).toBe(false)\n    })\n\n    it('should handle empty checkers array', async () => {\n      const result = await accessOR()(mockArgs)\n\n      expect(result).toBe(false)\n    })\n\n    it('should handle complex nested Where queries', async () => {\n      const checker1: Access = async () =>\n        ({\n          and: [{ customer: { equals: '123' } }, { status: { equals: 'active' } }],\n        }) as Where\n      const checker2: Access = async () => ({\n        role: { equals: 'admin' },\n      })\n\n      const result = await accessOR(checker1, checker2)(mockArgs)\n\n      expect(result).toEqual({\n        or: [\n          { and: [{ customer: { equals: '123' } }, { status: { equals: 'active' } }] },\n          { role: { equals: 'admin' } },\n        ],\n      })\n    })\n  })\n\n  describe('and', () => {\n    it('should return false when any checker returns false', async () => {\n      const checker1: Access = async () => true\n      const checker2: Access = async () => false\n\n      const result = await accessAND(checker1, checker2)(mockArgs)\n\n      expect(result).toBe(false)\n    })\n\n    it('should return true when all checkers return true', async () => {\n      const checker1: Access = async () => true\n      const checker2: Access = async () => true\n      const checker3: Access = async () => true\n\n      const result = await accessAND(checker1, checker2, checker3)(mockArgs)\n\n      expect(result).toBe(true)\n    })\n\n    it('should combine Where queries with AND logic', async () => {\n      const checker1: Access = async () => ({\n        customer: { equals: '123' },\n      })\n      const checker2: Access = async () => ({\n        status: { equals: 'published' },\n      })\n\n      const result = await accessAND(checker1, checker2)(mockArgs)\n\n      expect(result).toEqual({\n        and: [{ customer: { equals: '123' } }, { status: { equals: 'published' } }],\n      })\n    })\n\n    it('should return false when one checker returns false and others return Where queries', async () => {\n      const checker1: Access = async () => ({\n        customer: { equals: '123' },\n      })\n      const checker2: Access = async () => false\n\n      const result = await accessAND(checker1, checker2)(mockArgs)\n\n      expect(result).toBe(false)\n    })\n\n    it('should return Where query when all checkers return Where queries except one returns true', async () => {\n      const checker1: Access = async () => true\n      const checker2: Access = async () => ({\n        customer: { equals: '123' },\n      })\n      const checker3: Access = async () => ({\n        status: { equals: 'published' },\n      })\n\n      const result = await accessAND(checker1, checker2, checker3)(mockArgs)\n\n      expect(result).toEqual({\n        and: [{ customer: { equals: '123' } }, { status: { equals: 'published' } }],\n      })\n    })\n\n    it('should short-circuit on first false result for performance', async () => {\n      let secondCheckerCalled = false\n\n      const checker1: Access = async () => false\n      const checker2: Access = async () => {\n        secondCheckerCalled = true\n        return true\n      }\n\n      await accessAND(checker1, checker2)(mockArgs)\n\n      expect(secondCheckerCalled).toBe(false)\n    })\n\n    it('should handle empty checkers array', async () => {\n      const result = await accessAND()(mockArgs)\n\n      expect(result).toBe(true)\n    })\n\n    it('should return a single Where query when only one checker returns a Where query', async () => {\n      const checker1: Access = async () => true\n      const checker2: Access = async () => ({\n        customer: { equals: '123' },\n      })\n      const checker3: Access = async () => true\n\n      const result = await accessAND(checker1, checker2, checker3)(mockArgs)\n\n      expect(result).toEqual({\n        and: [{ customer: { equals: '123' } }],\n      })\n    })\n\n    it('should handle complex nested Where queries', async () => {\n      const checker1: Access = async () => ({\n        or: [{ customer: { equals: '123' } }, { customer: { equals: '456' } }],\n      })\n      const checker2: Access = async () => ({\n        status: { equals: 'active' },\n      })\n\n      const result = await accessAND(checker1, checker2)(mockArgs)\n\n      expect(result).toEqual({\n        and: [\n          { or: [{ customer: { equals: '123' } }, { customer: { equals: '456' } }] },\n          { status: { equals: 'active' } },\n        ],\n      })\n    })\n\n    it('should return false immediately when first checker returns false', async () => {\n      const checker1: Access = async () => false\n      const checker2: Access = async () => {\n        throw new Error('Should not be called')\n      }\n\n      const result = await accessAND(checker1, checker2)(mockArgs)\n\n      expect(result).toBe(false)\n    })\n  })\n\n  describe('conditional', () => {\n    it('should apply checker when condition is true', async () => {\n      const checker: Access = async () => true\n\n      const result = await conditional(true, checker)(mockArgs)\n\n      expect(result).toBe(true)\n    })\n\n    it('should return false when condition is false', async () => {\n      const checker: Access = async () => true\n\n      const result = await conditional(false, checker)(mockArgs)\n\n      expect(result).toBe(false)\n    })\n\n    it('should apply checker when condition function returns true', async () => {\n      const condition = ({ req }: AccessArgs) => !!req.user\n      const checker: Access = async () => true\n\n      const result = await conditional(condition, checker)(mockArgsWithUser)\n\n      expect(result).toBe(true)\n    })\n\n    it('should return false when condition function returns false', async () => {\n      const condition = ({ req }: AccessArgs) => !!req.user\n      const checker: Access = async () => true\n\n      const result = await conditional(condition, checker)(mockArgs)\n\n      expect(result).toBe(false)\n    })\n\n    it('should pass Where query through when condition is true', async () => {\n      const checker: Access = async () => ({\n        customer: { equals: '123' },\n      })\n\n      const result = await conditional(true, checker)(mockArgs)\n\n      expect(result).toEqual({\n        customer: { equals: '123' },\n      })\n    })\n\n    it('should not call checker when condition is false', async () => {\n      let checkerCalled = false\n\n      const checker: Access = async () => {\n        checkerCalled = true\n        return true\n      }\n\n      await conditional(false, checker)(mockArgs)\n\n      expect(checkerCalled).toBe(false)\n    })\n\n    it('should evaluate condition function each time', async () => {\n      const condition = ({ req }: AccessArgs) => !!req.user\n      const checker: Access = async () => true\n\n      // First call without user\n      const result1 = await conditional(condition, checker)(mockArgs)\n      expect(result1).toBe(false)\n\n      // Second call with user\n      const result2 = await conditional(condition, checker)(mockArgsWithUser)\n      expect(result2).toBe(true)\n    })\n\n    it('should work with false checker result when condition is true', async () => {\n      const checker: Access = async () => false\n\n      const result = await conditional(true, checker)(mockArgs)\n\n      expect(result).toBe(false)\n    })\n  })\n\n  describe('combined composition', () => {\n    it('should compose or, and, and conditional together', async () => {\n      const isAdmin: Access = async ({ req }) => req.user?.role === 'admin'\n      const isOwner: Access = async ({ req }) => ({\n        customer: { equals: req.user?.id },\n      })\n      const isGuest: Access = async ({ req }) => !req.user\n\n      const allowGuestCarts = true\n\n      const access = accessOR(isAdmin, accessAND(isOwner), conditional(allowGuestCarts, isGuest))\n\n      // Guest user (no user)\n      const guestResult = await access(mockArgs)\n      expect(guestResult).toBe(true)\n\n      // Admin user\n      const adminResult = await access({\n        req: {\n          user: { id: '123', role: 'admin' },\n          headers: new Headers(),\n          payload: {} as any,\n          context: {},\n        } as any,\n      })\n      expect(adminResult).toBe(true)\n\n      // Regular user (owner)\n      const ownerResult = await access({\n        req: {\n          user: { id: '123', role: 'customer' },\n          headers: new Headers(),\n          payload: {} as any,\n          context: {},\n        } as any,\n      })\n      expect(ownerResult).toEqual({\n        or: [{ and: [{ customer: { equals: '123' } }] }],\n      })\n    })\n\n    it('should handle complex nested compositions', async () => {\n      const checker1: Access = async () => ({\n        status: { equals: 'published' },\n      })\n      const checker2: Access = async () => ({\n        visibility: { equals: 'public' },\n      })\n      const checker3: Access = async ({ req }) => !!req.user\n      const checker4: Access = async () => ({\n        customer: { equals: '123' },\n      })\n\n      // ((published AND public) OR (authenticated AND customer=123))\n      const access = accessOR(accessAND(checker1, checker2), accessAND(checker3, checker4))\n\n      // Without user\n      const result1 = await access(mockArgs)\n      expect(result1).toEqual({\n        or: [\n          {\n            and: [{ status: { equals: 'published' } }, { visibility: { equals: 'public' } }],\n          },\n        ],\n      })\n\n      // With user\n      const result2 = await access(mockArgsWithUser)\n      expect(result2).toEqual({\n        or: [\n          {\n            and: [{ status: { equals: 'published' } }, { visibility: { equals: 'public' } }],\n          },\n          {\n            and: [{ customer: { equals: '123' } }],\n          },\n        ],\n      })\n    })\n\n    it('should handle conditional inside or composition', async () => {\n      const isAdmin: Access = async () => false\n      const isGuest: Access = async () => true\n      const allowGuestAccess = true\n\n      const access = accessOR(isAdmin, conditional(allowGuestAccess, isGuest))\n\n      const result = await access(mockArgs)\n      expect(result).toBe(true)\n    })\n\n    it('should handle conditional inside and composition', async () => {\n      const hasPermission: Access = async () => ({\n        permissions: { contains: 'read' },\n      })\n      const isActiveUser: Access = async () => true\n      const featureFlagEnabled = true\n\n      const access = accessAND(hasPermission, conditional(featureFlagEnabled, isActiveUser))\n\n      const result = await access(mockArgs)\n      expect(result).toEqual({\n        and: [{ permissions: { contains: 'read' } }],\n      })\n    })\n\n    it('should correctly handle multiple levels of nesting', async () => {\n      const a: Access = async () => true\n      const b: Access = async () => false\n      const c: Access = async () => ({ field1: { equals: 'value1' } })\n      const d: Access = async () => ({ field2: { equals: 'value2' } })\n\n      // (a AND (b OR (c AND d)))\n      const access = accessAND(a, accessOR(b, accessAND(c, d)))\n\n      const result = await access(mockArgs)\n      expect(result).toEqual({\n        and: [\n          { or: [{ and: [{ field1: { equals: 'value1' } }, { field2: { equals: 'value2' } }] }] },\n        ],\n      })\n    })\n  })\n\n  describe('edge cases and failure scenarios', () => {\n    it('should handle checker that throws an error', async () => {\n      const checker1: Access = async () => {\n        throw new Error('Access check failed')\n      }\n      const checker2: Access = async () => true\n\n      await expect(accessOR(checker1, checker2)(mockArgs)).rejects.toThrow('Access check failed')\n    })\n\n    it('should handle null or undefined returns gracefully', async () => {\n      const checker1: Access = async () => null as any\n      const checker2: Access = async () => undefined as any\n      const checker3: Access = async () => true\n\n      const result = await accessOR(checker1, checker2, checker3)(mockArgs)\n      expect(result).toBe(true)\n    })\n\n    it('should handle deeply nested Where queries', async () => {\n      const checker: Access = async () =>\n        ({\n          and: [\n            {\n              or: [\n                { field1: { equals: 'value1' } },\n                {\n                  and: [{ field2: { equals: 'value2' } }, { field3: { equals: 'value3' } }],\n                },\n              ],\n            },\n            { field4: { not_equals: 'value4' } },\n          ],\n        }) as Where\n\n      const result = await accessOR(checker)(mockArgs)\n\n      expect(result).toEqual({\n        or: [\n          {\n            and: [\n              {\n                or: [\n                  { field1: { equals: 'value1' } },\n                  {\n                    and: [{ field2: { equals: 'value2' } }, { field3: { equals: 'value3' } }],\n                  },\n                ],\n              },\n              { field4: { not_equals: 'value4' } },\n            ],\n          },\n        ],\n      })\n    })\n\n    it('should handle async checker that takes time', async () => {\n      const checker1: Access = async () => {\n        await new Promise((resolve) => setTimeout(resolve, 10))\n        return false\n      }\n      const checker2: Access = async () => {\n        await new Promise((resolve) => setTimeout(resolve, 10))\n        return true\n      }\n\n      const start = Date.now()\n      const result = await accessOR(checker1, checker2)(mockArgs)\n      const duration = Date.now() - start\n\n      expect(result).toBe(true)\n      expect(duration).toBeGreaterThanOrEqual(20)\n    })\n\n    it('should handle all checkers returning null/undefined', async () => {\n      const checker1: Access = async () => null as any\n      const checker2: Access = async () => undefined as any\n\n      const result = await accessOR(checker1, checker2)(mockArgs)\n\n      // null and undefined should be treated as false\n      expect(result).toBe(false)\n    })\n\n    it('should handle Where query with empty object', async () => {\n      const checker: Access = async () => ({}) as Where\n\n      const result = await accessOR(checker)(mockArgs)\n\n      expect(result).toEqual({})\n    })\n\n    it('should handle conditional with complex condition function', async () => {\n      const condition = ({ req }: AccessArgs): boolean => {\n        return !!(req.user && req.user.email && req.user.email.endsWith('@admin.com'))\n      }\n\n      const checker: Access = async () => true\n\n      // Non-admin email\n      const result1 = await conditional(\n        condition,\n        checker,\n      )({\n        req: {\n          user: { id: '123', email: 'user@example.com' },\n          headers: new Headers(),\n          payload: {} as any,\n          context: {},\n        } as any,\n      })\n      expect(result1).toBe(false)\n\n      // Admin email\n      const result2 = await conditional(\n        condition,\n        checker,\n      )({\n        req: {\n          user: { id: '123', email: 'admin@admin.com' },\n          headers: new Headers(),\n          payload: {} as any,\n          context: {},\n        } as any,\n      })\n      expect(result2).toBe(true)\n    })\n\n    it('should handle very large number of checkers in or', async () => {\n      const checkers: Access[] = Array.from({ length: 100 }, (_, i) => async () => ({\n        field: { equals: `value${i}` },\n      }))\n\n      const result = await accessOR(...checkers)(mockArgs)\n\n      expect(result).toHaveProperty('or')\n      expect((result as any).or).toHaveLength(100)\n    })\n\n    it('should handle very large number of checkers in and', async () => {\n      const checkers: Access[] = Array.from({ length: 100 }, (_, i) => async () => ({\n        field: { equals: `value${i}` },\n      }))\n\n      const result = await accessAND(...checkers)(mockArgs)\n\n      expect(result).toHaveProperty('and')\n      expect((result as any).and).toHaveLength(100)\n    })\n\n    it('should handle alternating true/false in or correctly', async () => {\n      const checkers: Access[] = [\n        async () => false,\n        async () => false,\n        async () => false,\n        async () => true, // This should cause short-circuit\n        async () => {\n          throw new Error('Should not be called')\n        },\n      ]\n\n      const result = await accessOR(...checkers)(mockArgs)\n\n      expect(result).toBe(true)\n    })\n\n    it('should handle alternating true/false in and correctly', async () => {\n      const checkers: Access[] = [\n        async () => true,\n        async () => true,\n        async () => false, // This should cause short-circuit\n        async () => {\n          throw new Error('Should not be called')\n        },\n      ]\n\n      const result = await accessAND(...checkers)(mockArgs)\n\n      expect(result).toBe(false)\n    })\n  })\n})\n"],"names":["accessAND","conditional","accessOR","mockArgs","req","user","headers","Headers","payload","context","mockArgsWithUser","id","email","describe","it","checker1","checker2","result","expect","toBe","checker3","customer","equals","status","toEqual","or","checker4","secondCheckerCalled","and","role","Error","checker","condition","checkerCalled","result1","result2","isAdmin","isOwner","isGuest","allowGuestCarts","access","guestResult","adminResult","ownerResult","visibility","allowGuestAccess","hasPermission","permissions","contains","isActiveUser","featureFlagEnabled","a","b","c","field1","d","field2","rejects","toThrow","undefined","field3","field4","not_equals","Promise","resolve","setTimeout","start","Date","now","duration","toBeGreaterThanOrEqual","endsWith","checkers","Array","from","length","_","i","field","toHaveProperty","toHaveLength"],"mappings":"AAEA,SAASA,SAAS,EAAEC,WAAW,EAAEC,QAAQ,QAAQ,sBAAqB;AAEtE,+BAA+B;AAC/B,MAAMC,WAAuB;IAC3BC,KAAK;QACHC,MAAM;QACNC,SAAS,IAAIC;QACbC,SAAS,CAAC;QACVC,SAAS,CAAC;IACZ;AACF;AAEA,MAAMC,mBAA+B;IACnCN,KAAK;QACHC,MAAM;YAAEM,IAAI;YAAOC,OAAO;QAAmB;QAC7CN,SAAS,IAAIC;QACbC,SAAS,CAAC;QACVC,SAAS,CAAC;IACZ;AACF;AAEAI,SAAS,gCAAgC;IACvCA,SAAS,MAAM;QACbC,GAAG,sDAAsD;YACvD,MAAMC,WAAmB,UAAY;YACrC,MAAMC,WAAmB,UAAY;YAErC,MAAMC,SAAS,MAAMf,SAASa,UAAUC,UAAUb;YAElDe,OAAOD,QAAQE,IAAI,CAAC;QACtB;QAEAL,GAAG,oDAAoD;YACrD,MAAMC,WAAmB,UAAY;YACrC,MAAMC,WAAmB,UAAY;YACrC,MAAMI,WAAmB,UAAY;YAErC,MAAMH,SAAS,MAAMf,SAASa,UAAUC,UAAUI,UAAUjB;YAE5De,OAAOD,QAAQE,IAAI,CAAC;QACtB;QAEAL,GAAG,sDAAsD;YACvD,MAAMC,WAAmB,UAAY;YACrC,MAAMC,WAAmB,UAAY;YACrC,MAAMI,WAAmB,UAAY;YAErC,MAAMH,SAAS,MAAMf,SAASa,UAAUC,UAAUI,UAAUjB;YAE5De,OAAOD,QAAQE,IAAI,CAAC;QACtB;QAEAL,GAAG,8CAA8C;YAC/C,MAAMC,WAAmB,UAAa,CAAA;oBACpCM,UAAU;wBAAEC,QAAQ;oBAAM;gBAC5B,CAAA;YACA,MAAMN,WAAmB,UAAa,CAAA;oBACpCO,QAAQ;wBAAED,QAAQ;oBAAY;gBAChC,CAAA;YAEA,MAAML,SAAS,MAAMf,SAASa,UAAUC,UAAUb;YAElDe,OAAOD,QAAQO,OAAO,CAAC;gBACrBC,IAAI;oBAAC;wBAAEJ,UAAU;4BAAEC,QAAQ;wBAAM;oBAAE;oBAAG;wBAAEC,QAAQ;4BAAED,QAAQ;wBAAY;oBAAE;iBAAE;YAC5E;QACF;QAEAR,GAAG,oFAAoF;YACrF,MAAMC,WAAmB,UAAa,CAAA;oBACpCM,UAAU;wBAAEC,QAAQ;oBAAM;gBAC5B,CAAA;YACA,MAAMN,WAAmB,UAAY;YAErC,MAAMC,SAAS,MAAMf,SAASa,UAAUC,UAAUb;YAElDe,OAAOD,QAAQE,IAAI,CAAC;QACtB;QAEAL,GAAG,2DAA2D;YAC5D,MAAMC,WAAmB,UAAY;YACrC,MAAMC,WAAmB,UAAa,CAAA;oBACpCK,UAAU;wBAAEC,QAAQ;oBAAM;gBAC5B,CAAA;YACA,MAAMF,WAAmB,UAAY;YACrC,MAAMM,WAAmB,UAAa,CAAA;oBACpCH,QAAQ;wBAAED,QAAQ;oBAAY;gBAChC,CAAA;YAEA,MAAML,SAAS,MAAMf,SAASa,UAAUC,UAAUI,UAAUM,UAAUvB;YAEtEe,OAAOD,QAAQO,OAAO,CAAC;gBACrBC,IAAI;oBAAC;wBAAEJ,UAAU;4BAAEC,QAAQ;wBAAM;oBAAE;oBAAG;wBAAEC,QAAQ;4BAAED,QAAQ;wBAAY;oBAAE;iBAAE;YAC5E;QACF;QAEAR,GAAG,kFAAkF;YACnF,MAAMC,WAAmB,UAAY;YACrC,MAAMC,WAAmB,UAAa,CAAA;oBACpCK,UAAU;wBAAEC,QAAQ;oBAAM;gBAC5B,CAAA;YACA,MAAMF,WAAmB,UAAY;YAErC,MAAMH,SAAS,MAAMf,SAASa,UAAUC,UAAUI,UAAUjB;YAE5De,OAAOD,QAAQO,OAAO,CAAC;gBACrBC,IAAI;oBAAC;wBAAEJ,UAAU;4BAAEC,QAAQ;wBAAM;oBAAE;iBAAE;YACvC;QACF;QAEAR,GAAG,6DAA6D;YAC9D,IAAIa,sBAAsB;YAE1B,MAAMZ,WAAmB,UAAY;YACrC,MAAMC,WAAmB;gBACvBW,sBAAsB;gBACtB,OAAO;YACT;YAEA,MAAMzB,SAASa,UAAUC,UAAUb;YAEnCe,OAAOS,qBAAqBR,IAAI,CAAC;QACnC;QAEAL,GAAG,sCAAsC;YACvC,MAAMG,SAAS,MAAMf,WAAWC;YAEhCe,OAAOD,QAAQE,IAAI,CAAC;QACtB;QAEAL,GAAG,8CAA8C;YAC/C,MAAMC,WAAmB,UACtB,CAAA;oBACCa,KAAK;wBAAC;4BAAEP,UAAU;gCAAEC,QAAQ;4BAAM;wBAAE;wBAAG;4BAAEC,QAAQ;gCAAED,QAAQ;4BAAS;wBAAE;qBAAE;gBAC1E,CAAA;YACF,MAAMN,WAAmB,UAAa,CAAA;oBACpCa,MAAM;wBAAEP,QAAQ;oBAAQ;gBAC1B,CAAA;YAEA,MAAML,SAAS,MAAMf,SAASa,UAAUC,UAAUb;YAElDe,OAAOD,QAAQO,OAAO,CAAC;gBACrBC,IAAI;oBACF;wBAAEG,KAAK;4BAAC;gCAAEP,UAAU;oCAAEC,QAAQ;gCAAM;4BAAE;4BAAG;gCAAEC,QAAQ;oCAAED,QAAQ;gCAAS;4BAAE;yBAAE;oBAAC;oBAC3E;wBAAEO,MAAM;4BAAEP,QAAQ;wBAAQ;oBAAE;iBAC7B;YACH;QACF;IACF;IAEAT,SAAS,OAAO;QACdC,GAAG,sDAAsD;YACvD,MAAMC,WAAmB,UAAY;YACrC,MAAMC,WAAmB,UAAY;YAErC,MAAMC,SAAS,MAAMjB,UAAUe,UAAUC,UAAUb;YAEnDe,OAAOD,QAAQE,IAAI,CAAC;QACtB;QAEAL,GAAG,oDAAoD;YACrD,MAAMC,WAAmB,UAAY;YACrC,MAAMC,WAAmB,UAAY;YACrC,MAAMI,WAAmB,UAAY;YAErC,MAAMH,SAAS,MAAMjB,UAAUe,UAAUC,UAAUI,UAAUjB;YAE7De,OAAOD,QAAQE,IAAI,CAAC;QACtB;QAEAL,GAAG,+CAA+C;YAChD,MAAMC,WAAmB,UAAa,CAAA;oBACpCM,UAAU;wBAAEC,QAAQ;oBAAM;gBAC5B,CAAA;YACA,MAAMN,WAAmB,UAAa,CAAA;oBACpCO,QAAQ;wBAAED,QAAQ;oBAAY;gBAChC,CAAA;YAEA,MAAML,SAAS,MAAMjB,UAAUe,UAAUC,UAAUb;YAEnDe,OAAOD,QAAQO,OAAO,CAAC;gBACrBI,KAAK;oBAAC;wBAAEP,UAAU;4BAAEC,QAAQ;wBAAM;oBAAE;oBAAG;wBAAEC,QAAQ;4BAAED,QAAQ;wBAAY;oBAAE;iBAAE;YAC7E;QACF;QAEAR,GAAG,sFAAsF;YACvF,MAAMC,WAAmB,UAAa,CAAA;oBACpCM,UAAU;wBAAEC,QAAQ;oBAAM;gBAC5B,CAAA;YACA,MAAMN,WAAmB,UAAY;YAErC,MAAMC,SAAS,MAAMjB,UAAUe,UAAUC,UAAUb;YAEnDe,OAAOD,QAAQE,IAAI,CAAC;QACtB;QAEAL,GAAG,4FAA4F;YAC7F,MAAMC,WAAmB,UAAY;YACrC,MAAMC,WAAmB,UAAa,CAAA;oBACpCK,UAAU;wBAAEC,QAAQ;oBAAM;gBAC5B,CAAA;YACA,MAAMF,WAAmB,UAAa,CAAA;oBACpCG,QAAQ;wBAAED,QAAQ;oBAAY;gBAChC,CAAA;YAEA,MAAML,SAAS,MAAMjB,UAAUe,UAAUC,UAAUI,UAAUjB;YAE7De,OAAOD,QAAQO,OAAO,CAAC;gBACrBI,KAAK;oBAAC;wBAAEP,UAAU;4BAAEC,QAAQ;wBAAM;oBAAE;oBAAG;wBAAEC,QAAQ;4BAAED,QAAQ;wBAAY;oBAAE;iBAAE;YAC7E;QACF;QAEAR,GAAG,8DAA8D;YAC/D,IAAIa,sBAAsB;YAE1B,MAAMZ,WAAmB,UAAY;YACrC,MAAMC,WAAmB;gBACvBW,sBAAsB;gBACtB,OAAO;YACT;YAEA,MAAM3B,UAAUe,UAAUC,UAAUb;YAEpCe,OAAOS,qBAAqBR,IAAI,CAAC;QACnC;QAEAL,GAAG,sCAAsC;YACvC,MAAMG,SAAS,MAAMjB,YAAYG;YAEjCe,OAAOD,QAAQE,IAAI,CAAC;QACtB;QAEAL,GAAG,kFAAkF;YACnF,MAAMC,WAAmB,UAAY;YACrC,MAAMC,WAAmB,UAAa,CAAA;oBACpCK,UAAU;wBAAEC,QAAQ;oBAAM;gBAC5B,CAAA;YACA,MAAMF,WAAmB,UAAY;YAErC,MAAMH,SAAS,MAAMjB,UAAUe,UAAUC,UAAUI,UAAUjB;YAE7De,OAAOD,QAAQO,OAAO,CAAC;gBACrBI,KAAK;oBAAC;wBAAEP,UAAU;4BAAEC,QAAQ;wBAAM;oBAAE;iBAAE;YACxC;QACF;QAEAR,GAAG,8CAA8C;YAC/C,MAAMC,WAAmB,UAAa,CAAA;oBACpCU,IAAI;wBAAC;4BAAEJ,UAAU;gCAAEC,QAAQ;4BAAM;wBAAE;wBAAG;4BAAED,UAAU;gCAAEC,QAAQ;4BAAM;wBAAE;qBAAE;gBACxE,CAAA;YACA,MAAMN,WAAmB,UAAa,CAAA;oBACpCO,QAAQ;wBAAED,QAAQ;oBAAS;gBAC7B,CAAA;YAEA,MAAML,SAAS,MAAMjB,UAAUe,UAAUC,UAAUb;YAEnDe,OAAOD,QAAQO,OAAO,CAAC;gBACrBI,KAAK;oBACH;wBAAEH,IAAI;4BAAC;gCAAEJ,UAAU;oCAAEC,QAAQ;gCAAM;4BAAE;4BAAG;gCAAED,UAAU;oCAAEC,QAAQ;gCAAM;4BAAE;yBAAE;oBAAC;oBACzE;wBAAEC,QAAQ;4BAAED,QAAQ;wBAAS;oBAAE;iBAChC;YACH;QACF;QAEAR,GAAG,oEAAoE;YACrE,MAAMC,WAAmB,UAAY;YACrC,MAAMC,WAAmB;gBACvB,MAAM,IAAIc,MAAM;YAClB;YAEA,MAAMb,SAAS,MAAMjB,UAAUe,UAAUC,UAAUb;YAEnDe,OAAOD,QAAQE,IAAI,CAAC;QACtB;IACF;IAEAN,SAAS,eAAe;QACtBC,GAAG,+CAA+C;YAChD,MAAMiB,UAAkB,UAAY;YAEpC,MAAMd,SAAS,MAAMhB,YAAY,MAAM8B,SAAS5B;YAEhDe,OAAOD,QAAQE,IAAI,CAAC;QACtB;QAEAL,GAAG,+CAA+C;YAChD,MAAMiB,UAAkB,UAAY;YAEpC,MAAMd,SAAS,MAAMhB,YAAY,OAAO8B,SAAS5B;YAEjDe,OAAOD,QAAQE,IAAI,CAAC;QACtB;QAEAL,GAAG,6DAA6D;YAC9D,MAAMkB,YAAY,CAAC,EAAE5B,GAAG,EAAc,GAAK,CAAC,CAACA,IAAIC,IAAI;YACrD,MAAM0B,UAAkB,UAAY;YAEpC,MAAMd,SAAS,MAAMhB,YAAY+B,WAAWD,SAASrB;YAErDQ,OAAOD,QAAQE,IAAI,CAAC;QACtB;QAEAL,GAAG,6DAA6D;YAC9D,MAAMkB,YAAY,CAAC,EAAE5B,GAAG,EAAc,GAAK,CAAC,CAACA,IAAIC,IAAI;YACrD,MAAM0B,UAAkB,UAAY;YAEpC,MAAMd,SAAS,MAAMhB,YAAY+B,WAAWD,SAAS5B;YAErDe,OAAOD,QAAQE,IAAI,CAAC;QACtB;QAEAL,GAAG,0DAA0D;YAC3D,MAAMiB,UAAkB,UAAa,CAAA;oBACnCV,UAAU;wBAAEC,QAAQ;oBAAM;gBAC5B,CAAA;YAEA,MAAML,SAAS,MAAMhB,YAAY,MAAM8B,SAAS5B;YAEhDe,OAAOD,QAAQO,OAAO,CAAC;gBACrBH,UAAU;oBAAEC,QAAQ;gBAAM;YAC5B;QACF;QAEAR,GAAG,mDAAmD;YACpD,IAAImB,gBAAgB;YAEpB,MAAMF,UAAkB;gBACtBE,gBAAgB;gBAChB,OAAO;YACT;YAEA,MAAMhC,YAAY,OAAO8B,SAAS5B;YAElCe,OAAOe,eAAed,IAAI,CAAC;QAC7B;QAEAL,GAAG,gDAAgD;YACjD,MAAMkB,YAAY,CAAC,EAAE5B,GAAG,EAAc,GAAK,CAAC,CAACA,IAAIC,IAAI;YACrD,MAAM0B,UAAkB,UAAY;YAEpC,0BAA0B;YAC1B,MAAMG,UAAU,MAAMjC,YAAY+B,WAAWD,SAAS5B;YACtDe,OAAOgB,SAASf,IAAI,CAAC;YAErB,wBAAwB;YACxB,MAAMgB,UAAU,MAAMlC,YAAY+B,WAAWD,SAASrB;YACtDQ,OAAOiB,SAAShB,IAAI,CAAC;QACvB;QAEAL,GAAG,gEAAgE;YACjE,MAAMiB,UAAkB,UAAY;YAEpC,MAAMd,SAAS,MAAMhB,YAAY,MAAM8B,SAAS5B;YAEhDe,OAAOD,QAAQE,IAAI,CAAC;QACtB;IACF;IAEAN,SAAS,wBAAwB;QAC/BC,GAAG,oDAAoD;YACrD,MAAMsB,UAAkB,OAAO,EAAEhC,GAAG,EAAE,GAAKA,IAAIC,IAAI,EAAEwB,SAAS;YAC9D,MAAMQ,UAAkB,OAAO,EAAEjC,GAAG,EAAE,GAAM,CAAA;oBAC1CiB,UAAU;wBAAEC,QAAQlB,IAAIC,IAAI,EAAEM;oBAAG;gBACnC,CAAA;YACA,MAAM2B,UAAkB,OAAO,EAAElC,GAAG,EAAE,GAAK,CAACA,IAAIC,IAAI;YAEpD,MAAMkC,kBAAkB;YAExB,MAAMC,SAAStC,SAASkC,SAASpC,UAAUqC,UAAUpC,YAAYsC,iBAAiBD;YAElF,uBAAuB;YACvB,MAAMG,cAAc,MAAMD,OAAOrC;YACjCe,OAAOuB,aAAatB,IAAI,CAAC;YAEzB,aAAa;YACb,MAAMuB,cAAc,MAAMF,OAAO;gBAC/BpC,KAAK;oBACHC,MAAM;wBAAEM,IAAI;wBAAOkB,MAAM;oBAAQ;oBACjCvB,SAAS,IAAIC;oBACbC,SAAS,CAAC;oBACVC,SAAS,CAAC;gBACZ;YACF;YACAS,OAAOwB,aAAavB,IAAI,CAAC;YAEzB,uBAAuB;YACvB,MAAMwB,cAAc,MAAMH,OAAO;gBAC/BpC,KAAK;oBACHC,MAAM;wBAAEM,IAAI;wBAAOkB,MAAM;oBAAW;oBACpCvB,SAAS,IAAIC;oBACbC,SAAS,CAAC;oBACVC,SAAS,CAAC;gBACZ;YACF;YACAS,OAAOyB,aAAanB,OAAO,CAAC;gBAC1BC,IAAI;oBAAC;wBAAEG,KAAK;4BAAC;gCAAEP,UAAU;oCAAEC,QAAQ;gCAAM;4BAAE;yBAAE;oBAAC;iBAAE;YAClD;QACF;QAEAR,GAAG,6CAA6C;YAC9C,MAAMC,WAAmB,UAAa,CAAA;oBACpCQ,QAAQ;wBAAED,QAAQ;oBAAY;gBAChC,CAAA;YACA,MAAMN,WAAmB,UAAa,CAAA;oBACpC4B,YAAY;wBAAEtB,QAAQ;oBAAS;gBACjC,CAAA;YACA,MAAMF,WAAmB,OAAO,EAAEhB,GAAG,EAAE,GAAK,CAAC,CAACA,IAAIC,IAAI;YACtD,MAAMqB,WAAmB,UAAa,CAAA;oBACpCL,UAAU;wBAAEC,QAAQ;oBAAM;gBAC5B,CAAA;YAEA,+DAA+D;YAC/D,MAAMkB,SAAStC,SAASF,UAAUe,UAAUC,WAAWhB,UAAUoB,UAAUM;YAE3E,eAAe;YACf,MAAMQ,UAAU,MAAMM,OAAOrC;YAC7Be,OAAOgB,SAASV,OAAO,CAAC;gBACtBC,IAAI;oBACF;wBACEG,KAAK;4BAAC;gCAAEL,QAAQ;oCAAED,QAAQ;gCAAY;4BAAE;4BAAG;gCAAEsB,YAAY;oCAAEtB,QAAQ;gCAAS;4BAAE;yBAAE;oBAClF;iBACD;YACH;YAEA,YAAY;YACZ,MAAMa,UAAU,MAAMK,OAAO9B;YAC7BQ,OAAOiB,SAASX,OAAO,CAAC;gBACtBC,IAAI;oBACF;wBACEG,KAAK;4BAAC;gCAAEL,QAAQ;oCAAED,QAAQ;gCAAY;4BAAE;4BAAG;gCAAEsB,YAAY;oCAAEtB,QAAQ;gCAAS;4BAAE;yBAAE;oBAClF;oBACA;wBACEM,KAAK;4BAAC;gCAAEP,UAAU;oCAAEC,QAAQ;gCAAM;4BAAE;yBAAE;oBACxC;iBACD;YACH;QACF;QAEAR,GAAG,mDAAmD;YACpD,MAAMsB,UAAkB,UAAY;YACpC,MAAME,UAAkB,UAAY;YACpC,MAAMO,mBAAmB;YAEzB,MAAML,SAAStC,SAASkC,SAASnC,YAAY4C,kBAAkBP;YAE/D,MAAMrB,SAAS,MAAMuB,OAAOrC;YAC5Be,OAAOD,QAAQE,IAAI,CAAC;QACtB;QAEAL,GAAG,oDAAoD;YACrD,MAAMgC,gBAAwB,UAAa,CAAA;oBACzCC,aAAa;wBAAEC,UAAU;oBAAO;gBAClC,CAAA;YACA,MAAMC,eAAuB,UAAY;YACzC,MAAMC,qBAAqB;YAE3B,MAAMV,SAASxC,UAAU8C,eAAe7C,YAAYiD,oBAAoBD;YAExE,MAAMhC,SAAS,MAAMuB,OAAOrC;YAC5Be,OAAOD,QAAQO,OAAO,CAAC;gBACrBI,KAAK;oBAAC;wBAAEmB,aAAa;4BAAEC,UAAU;wBAAO;oBAAE;iBAAE;YAC9C;QACF;QAEAlC,GAAG,sDAAsD;YACvD,MAAMqC,IAAY,UAAY;YAC9B,MAAMC,IAAY,UAAY;YAC9B,MAAMC,IAAY,UAAa,CAAA;oBAAEC,QAAQ;wBAAEhC,QAAQ;oBAAS;gBAAE,CAAA;YAC9D,MAAMiC,IAAY,UAAa,CAAA;oBAAEC,QAAQ;wBAAElC,QAAQ;oBAAS;gBAAE,CAAA;YAE9D,2BAA2B;YAC3B,MAAMkB,SAASxC,UAAUmD,GAAGjD,SAASkD,GAAGpD,UAAUqD,GAAGE;YAErD,MAAMtC,SAAS,MAAMuB,OAAOrC;YAC5Be,OAAOD,QAAQO,OAAO,CAAC;gBACrBI,KAAK;oBACH;wBAAEH,IAAI;4BAAC;gCAAEG,KAAK;oCAAC;wCAAE0B,QAAQ;4CAAEhC,QAAQ;wCAAS;oCAAE;oCAAG;wCAAEkC,QAAQ;4CAAElC,QAAQ;wCAAS;oCAAE;iCAAE;4BAAC;yBAAE;oBAAC;iBACvF;YACH;QACF;IACF;IAEAT,SAAS,oCAAoC;QAC3CC,GAAG,8CAA8C;YAC/C,MAAMC,WAAmB;gBACvB,MAAM,IAAIe,MAAM;YAClB;YACA,MAAMd,WAAmB,UAAY;YAErC,MAAME,OAAOhB,SAASa,UAAUC,UAAUb,WAAWsD,OAAO,CAACC,OAAO,CAAC;QACvE;QAEA5C,GAAG,sDAAsD;YACvD,MAAMC,WAAmB,UAAY;YACrC,MAAMC,WAAmB,UAAY2C;YACrC,MAAMvC,WAAmB,UAAY;YAErC,MAAMH,SAAS,MAAMf,SAASa,UAAUC,UAAUI,UAAUjB;YAC5De,OAAOD,QAAQE,IAAI,CAAC;QACtB;QAEAL,GAAG,6CAA6C;YAC9C,MAAMiB,UAAkB,UACrB,CAAA;oBACCH,KAAK;wBACH;4BACEH,IAAI;gCACF;oCAAE6B,QAAQ;wCAAEhC,QAAQ;oCAAS;gCAAE;gCAC/B;oCACEM,KAAK;wCAAC;4CAAE4B,QAAQ;gDAAElC,QAAQ;4CAAS;wCAAE;wCAAG;4CAAEsC,QAAQ;gDAAEtC,QAAQ;4CAAS;wCAAE;qCAAE;gCAC3E;6BACD;wBACH;wBACA;4BAAEuC,QAAQ;gCAAEC,YAAY;4BAAS;wBAAE;qBACpC;gBACH,CAAA;YAEF,MAAM7C,SAAS,MAAMf,SAAS6B,SAAS5B;YAEvCe,OAAOD,QAAQO,OAAO,CAAC;gBACrBC,IAAI;oBACF;wBACEG,KAAK;4BACH;gCACEH,IAAI;oCACF;wCAAE6B,QAAQ;4CAAEhC,QAAQ;wCAAS;oCAAE;oCAC/B;wCACEM,KAAK;4CAAC;gDAAE4B,QAAQ;oDAAElC,QAAQ;gDAAS;4CAAE;4CAAG;gDAAEsC,QAAQ;oDAAEtC,QAAQ;gDAAS;4CAAE;yCAAE;oCAC3E;iCACD;4BACH;4BACA;gCAAEuC,QAAQ;oCAAEC,YAAY;gCAAS;4BAAE;yBACpC;oBACH;iBACD;YACH;QACF;QAEAhD,GAAG,+CAA+C;YAChD,MAAMC,WAAmB;gBACvB,MAAM,IAAIgD,QAAQ,CAACC,UAAYC,WAAWD,SAAS;gBACnD,OAAO;YACT;YACA,MAAMhD,WAAmB;gBACvB,MAAM,IAAI+C,QAAQ,CAACC,UAAYC,WAAWD,SAAS;gBACnD,OAAO;YACT;YAEA,MAAME,QAAQC,KAAKC,GAAG;YACtB,MAAMnD,SAAS,MAAMf,SAASa,UAAUC,UAAUb;YAClD,MAAMkE,WAAWF,KAAKC,GAAG,KAAKF;YAE9BhD,OAAOD,QAAQE,IAAI,CAAC;YACpBD,OAAOmD,UAAUC,sBAAsB,CAAC;QAC1C;QAEAxD,GAAG,uDAAuD;YACxD,MAAMC,WAAmB,UAAY;YACrC,MAAMC,WAAmB,UAAY2C;YAErC,MAAM1C,SAAS,MAAMf,SAASa,UAAUC,UAAUb;YAElD,gDAAgD;YAChDe,OAAOD,QAAQE,IAAI,CAAC;QACtB;QAEAL,GAAG,+CAA+C;YAChD,MAAMiB,UAAkB,UAAa,CAAA,CAAC,CAAA;YAEtC,MAAMd,SAAS,MAAMf,SAAS6B,SAAS5B;YAEvCe,OAAOD,QAAQO,OAAO,CAAC,CAAC;QAC1B;QAEAV,GAAG,6DAA6D;YAC9D,MAAMkB,YAAY,CAAC,EAAE5B,GAAG,EAAc;gBACpC,OAAO,CAAC,CAAEA,CAAAA,IAAIC,IAAI,IAAID,IAAIC,IAAI,CAACO,KAAK,IAAIR,IAAIC,IAAI,CAACO,KAAK,CAAC2D,QAAQ,CAAC,aAAY;YAC9E;YAEA,MAAMxC,UAAkB,UAAY;YAEpC,kBAAkB;YAClB,MAAMG,UAAU,MAAMjC,YACpB+B,WACAD,SACA;gBACA3B,KAAK;oBACHC,MAAM;wBAAEM,IAAI;wBAAOC,OAAO;oBAAmB;oBAC7CN,SAAS,IAAIC;oBACbC,SAAS,CAAC;oBACVC,SAAS,CAAC;gBACZ;YACF;YACAS,OAAOgB,SAASf,IAAI,CAAC;YAErB,cAAc;YACd,MAAMgB,UAAU,MAAMlC,YACpB+B,WACAD,SACA;gBACA3B,KAAK;oBACHC,MAAM;wBAAEM,IAAI;wBAAOC,OAAO;oBAAkB;oBAC5CN,SAAS,IAAIC;oBACbC,SAAS,CAAC;oBACVC,SAAS,CAAC;gBACZ;YACF;YACAS,OAAOiB,SAAShB,IAAI,CAAC;QACvB;QAEAL,GAAG,qDAAqD;YACtD,MAAM0D,WAAqBC,MAAMC,IAAI,CAAC;gBAAEC,QAAQ;YAAI,GAAG,CAACC,GAAGC,IAAM,UAAa,CAAA;wBAC5EC,OAAO;4BAAExD,QAAQ,CAAC,KAAK,EAAEuD,GAAG;wBAAC;oBAC/B,CAAA;YAEA,MAAM5D,SAAS,MAAMf,YAAYsE,UAAUrE;YAE3Ce,OAAOD,QAAQ8D,cAAc,CAAC;YAC9B7D,OAAO,AAACD,OAAeQ,EAAE,EAAEuD,YAAY,CAAC;QAC1C;QAEAlE,GAAG,sDAAsD;YACvD,MAAM0D,WAAqBC,MAAMC,IAAI,CAAC;gBAAEC,QAAQ;YAAI,GAAG,CAACC,GAAGC,IAAM,UAAa,CAAA;wBAC5EC,OAAO;4BAAExD,QAAQ,CAAC,KAAK,EAAEuD,GAAG;wBAAC;oBAC/B,CAAA;YAEA,MAAM5D,SAAS,MAAMjB,aAAawE,UAAUrE;YAE5Ce,OAAOD,QAAQ8D,cAAc,CAAC;YAC9B7D,OAAO,AAACD,OAAeW,GAAG,EAAEoD,YAAY,CAAC;QAC3C;QAEAlE,GAAG,wDAAwD;YACzD,MAAM0D,WAAqB;gBACzB,UAAY;gBACZ,UAAY;gBACZ,UAAY;gBACZ,UAAY;gBACZ;oBACE,MAAM,IAAI1C,MAAM;gBAClB;aACD;YAED,MAAMb,SAAS,MAAMf,YAAYsE,UAAUrE;YAE3Ce,OAAOD,QAAQE,IAAI,CAAC;QACtB;QAEAL,GAAG,yDAAyD;YAC1D,MAAM0D,WAAqB;gBACzB,UAAY;gBACZ,UAAY;gBACZ,UAAY;gBACZ;oBACE,MAAM,IAAI1C,MAAM;gBAClB;aACD;YAED,MAAMb,SAAS,MAAMjB,aAAawE,UAAUrE;YAE5Ce,OAAOD,QAAQE,IAAI,CAAC;QACtB;IACF;AACF"}